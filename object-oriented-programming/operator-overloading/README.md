## Предефиниране на оператори  
- C++ позволява на програмистите да задават ново значение и функционалност на знаците за операции - **предефиниране на оператори**

### Ползи 
- По-лесно и по-интруитивно за използване е прилагането на операция, а не извикване на функция
- Позволяват по-сбито извикване (без да се използват скоби при изпълнението на операцията)

### Ограничения  
- Предефинирането е позволено, само ако поне един от операндите е обект от клас
- Не се допуска п редефиниране на операции между стандартни типове, например операцията + между два int, тъй като това би променило смисъла (семантиката) на операцията

## Видове оператори

### Операциите са
- Унарни - с един операнд, например `!b`
- Бинарни - сдва операнда, например `a + b`

### Всяка операция се характеризира с
- Позиция на знака спряма операнда или операндите му
- Приоритет
- Асоцииране на последователни операции

### Позицията на оператора спрямо операнда го определя като
- Префиксен: `++a`
- Инфиксен: `a + b`
- Постфиксен: `a++`
  
  
- Приоритетът на операциите определя реда на тяхноъо изпълнение в израз
- Асоциирането на операциите определя реда на изпълнение на последователно записани операции с еднакъв приоритет

### Видове оператори спрямо асоциативността:
- Ляво асоциативни - изпълняват се от ляво на дясно
- Дясно асоциативни - изпълняват се от дясно на ляво

### Пример  
- Ляво асоциативни операции: `a + b - c` се изпълнява като `(a + b) - c`
- Дясно асоциативни операции `a = b = c` се изпълнява като `a = (b = c)`

### Оператори, които не могат да се предефинират:
- Оператор за избор на компоненти `.`
- Оператор за избор на компоненти на клас чрез указател `*`
- Оператор за област на действие `::`
- Троен оператор `?:`
- Оператор `sizeof`

## Операторни функции
### Операциите в C++ могат да бъдат предефинирани като:
- обикновенни функции, извън дефиницията на кой да е клас
- [член-функции](https://github.com/MadForLife/university/tree/main/object-oriented-programming/01.%20Classes.%20Encapsulation.%20Member-functions.%20Constructors.%20Destructors#%D1%87%D0%BB%D0%B5%D0%BD-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8) на клас

### Предефиниране като функция
```
<тип-на-резултат> operator<знак-на-операция> (<параметри: . . .>)
{
  <тяло>
}
```
---
```
int operator-(const Time &a, const Time &b)
{
  return a.seconds_from(b);
}
```

## Операторни член-функции  
- Операциите могат да бъдат предефинирани и като член-функции
- Например, препоръчва се различните форми за присвояване да бъдат дефинирани като член-функции
- За повечето оператори програмистът избира начина на предефиниране - като функция или като член-функция
- Синтаксисът за извикване на оператора е един и същ (единствено и саамо чрез знака на операцията), независимо дали е предефиниран като функция или член-функция

### При избора дали даден оператор да се предефинира като глобална функция или член-функция, трябва да се има предвид  
- Функция, която не е член на класа, обикновено **няма достъп до частните елементи на класа** (освен ако не е приятел на класа), докато член-функцията има
- **Стандартните типове (напр. `int` или `double`** могат да бъдат само десни операнди в член-функция, но могат да бъдат и **леви операнди** в **глобално** предефиниране операция.
- ***Използвайте предефиниране на операторите чрез глобални функции, когато левият операнд е от стандартен тип***

## Предефиниране - функции-приятели или член-функции  

### Предефиниране като **член-функции или функции-приятели**
- Когато предефинирането на оператор изисква достъп до **private** или **protected** компоненти на класа
- Когато първият (или единственият) операнд на оператора е обект на класа или псевдоним на обект на класа

### Предефиниране като **член-функции, задължително** за
- Операторите `()`, `[]`, `->` и `=`

### Предефиниране като глобални **функции-приятели**
- Ако първият или единствен операнд е обект на друг клас, или псевдоним на обект на друг клас или е от стандартен тип  
`"int, double, char, . . ."`
- Операторите `>>` и `<<` се предефинират като функции-приятели тъй като първи операнд за тях е поток

## Предефиниране на унарни оператори  
### Унарен оператор може да се предефинира, като
- Нестатична член-функция на класа без явно указан аргумент
- Като функция-приятел с един аргумент, който трябва да е или обект на класа, или псевдоним на обект на класа

```
class Rational
{
  friend bool operator! (const Rational &);
}
```
- В началото на декларацията на класа указваме, кои са неговите приятели, члез ключовата дума ***friend***
### Приятелски функции на клас - синтаксис
- В рамките на класа декларираме прототип на функцията, която искаме да направим приятел
```
friend <тип-на-резултат> <име-на-функция> (<списък с параметри>);
```
- Извън класа описваме функцията
```
bool operator! (const Rational &r)
{
  return r.number == 0;
}
```

### Предефиниране на оператора `!` за класа Rational, чрез член-функция на класа
```
class Rational
{
  public:
    bool operator!() const;
};

bool Rational::operator!() const
{
  return number == 0;
}
```

## Предефиниране на унарните оператори `++` и `--`
- Операторите `++` и `--` са както **префиксни** `++a`, така и постфиксни `a--`
- При предефиниране на `++` и `--`, за да се различават префиксните от постфиксните версии, трябва да се зададат различни прототипи
- Префиксните версии се **реализират стандартно**
- Постфиксните версии се реализират, като се добавя **допълнителен аргумент от тип `int`**
- Използването на допълнителен аргумент от тип `int` подсказва на компилатора, че дефинираната операция е постфиксна

## Предефиниране на бинарни оператори  
### При предефинирането на **бинарни операции** са налице следните възможности
- Предефиниране като **външна операторна функция** с два ргумента (един от тях трябва да е обект на клас или псевдоним на обект на клас)
- Като нестатична **член-функция** на клас с ляв операнд
- - обект от класа и втори операнд - липсващ или от какъвто и да е тип
- Като **глобална функция-приятел** с два аргумента, от които единият е обект от клас или псевдоним на обект от клас

## Предефиниране на оператор за присвояване  
- Прието е **предефинирането на присвояване винаги да се дефинира като член-функция, защото от лявата страна на знака трябва да стои псевдоним на обект. Най-просто е това да бъде [*this](https://github.com/MadForLife/university/tree/main/object-oriented-programming/01.%20Classes.%20Encapsulation.%20Member-functions.%20Constructors.%20Destructors#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB-this)

```
//декларация
<име-на-клас>& operator= (const <име-на-клас> &);

//дефиниция
<име-на-клас>& <име-на-клас>::operator= (const <име-на-клас>& r
{
  if (*this != r)
  {
    //освобождаване на ресурсите, свързани с текущия обект *this, ако има такива
    //копиране на компонентите на r в съответните на *this
  }
  return *this;
}
```

## Предефиниране на `=`  
- Копиращият конструктор и предефинирането на оператор = са доста сходни
- Разликата е - операторната функция за присвояване извършва действията си над **сочения от указателя this съществуващ обект**, а не над току що създаден обект
- При операторната функция за присвояване трябва предварително **да се освободят свързаните с обекта ресурси**
- Операторната функция за присвояване приема като параметър обект от класа, като е препоръчително той да бъде подаден като **псевдоним ида е константен**
- Операторната функция за присвояване **връща като резултат псевдоним на обекта сочен от указателя **this**

## Предефиниране на `>`  
- Предефинирането на операциите за сравнение `>` или `<` може да бвъде реализирано както като член-функция, така и като глобална **функция-приятел
```
class Student
{
  friend bool operator> (const Student&, const Student&);
  
  public:
  ...
};

bool operator> (const Student& lhs, const Student& rhs)
{
  return lhs.grade > r.grade;
}
```

## Предефиниране на достъп до потоци
- Оригинално знаците `<<` и `>>` означават бинарната операция двоично изместване вляво и вдясно
- В библиотечните класове за входни и изходни потоци тези знаци са предефинирани за обмен между стандартните типове и потоците чрез следните функции:

### За изходен поток
`ostream& operator<< (ostream& out, char value)`  
`ostream& operator<< (ostream& out, int value)`  
`ostream& operator<< (ostream& out, float value)`  
`ostream& operator<< (ostream& out, double value)`  
`ostream& operator<< (ostream& out, bool value)`  
`ostream& operator<< (ostream& out, const char* value)`  

## Предефиниране на вход-изход  
- Всеки от операторите `<<` или `>>` приема като ляяв аргумент **поток**, а като десен **друга стойност**
- При изпълнение всеки **оператор ще промени потока**, като изпрати в или изтегли от потока символи за десния си аргумент
- Като резултат се **връща отново поток**, но променен
- Това позволява да се **изграждат изрази** с потоци

## Входен поток  
- Операторът `>>` се използва за входен поток
- Може да бъде предефиниран, за да работи за новите типове данни дефинирани от потребителя

### Нека приемем, че данните за рационално число са въведени като две цели числа, например: 3 8

```
istream & operator >> (istream & in, Rational & rhs)
{
  int num, den;
  in >> num >> den;
  rhs = Rational(num, den);
  return in;
}
```
- Вторият аргумент трябва да е неконстантен псевдоним към обект, тъй като се променя с въведените от конзолата символи
- Операторът трябва да върне отново поток, за да е възможно верижно извикване на операцията: `in >> r >> x;` Първо от потока ще се изтеглят символите за rhs,
ако за обекта r е дефинирана горната операция, после от вече изменения поток ще се изтегли х според неговата операция и пр.
- Ако предпочитаме рационално число да се въвежда като 3/8
- Тогава предефинираният оператор >> би изглеждал така 
```
istream & operator >> (istream & in, Rational * r)
{
  int t, b;
  in >> t;
  char c;
  in >> c;
  if (c == '/')
  {
    in >> b;
  }
  else
  {
    in.unget();
    b = 1;
  }
  r = Rational(t, b);
  return in;
}
```

## Предефиниране на комбинирани оператори
- Ако имаме предефинирани операторите `+` и отделно `=`, не означава че имаме предефиниран оператор `+=`
```
class Rational
{
  public:
    ...
    Rational& operator += (const Rational&);
};

Rational& Rational::operator+= (const Rational& right)
{
  number = number*right.denom+denom*right.numberr;
  denom *= right.denom;
  return *this;
}
```
